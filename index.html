<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Лётограф</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
      }
      .signal-label {
        background: transparent;
        border: none;
        box-shadow: none;
        padding: 0;
        color: red;
        font-size: 200%;
      }
      .leaflet-control-attribution {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      const map = L.map("map", { attributionControl: false });
      const markers = new Map();
      const lines = new Map();
      let initialized = false;

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 26,
      }).addTo(map);

      function colorFromSignal(r) {
        if (r >= 0) return "#999";
        const strength = Math.min(Math.abs(r) / 100, 1);
        const hue = (1 - strength) * 120; // 120=green, 0=red
        return `hsl(${hue}, 100%, 50%)`;
      }

      function updateGraph(data) {
        const bounds = [];
        const currentIds = new Set();
        for (const [id, info] of Object.entries(data)) {
          const lat = info.gps_lat;
          const lng = info.gps_lan;
          if (lat != null && lng != null) {
            currentIds.add(id);
            const latlng = [lat, lng];
            bounds.push(latlng);
            if (!markers.has(id)) {
              markers.set(
                id,
                L.marker(latlng).addTo(map).bindPopup(`Node ${id}`)
              );
            } else {
              markers.get(id).setLatLng(latlng);
            }
          }
        }
        const seen = new Set();
        for (const [id, info] of Object.entries(data)) {
          const lat1 = info.gps_lat;
          const lng1 = info.gps_lan;
          if (lat1 == null || lng1 == null) continue;
          const neighbors = info.neighbors
            ? Object.values(info.neighbors)
            : [];
          neighbors.forEach((n) => {
            if (n.n > 0 && n.r < 0 && data[n.n]) {
              const other = data[n.n];
              const lat2 = other.gps_lat;
              const lng2 = other.gps_lan;
              if (lat2 == null || lng2 == null) return;
              const key = [id, n.n].sort().join("-");
              const coords = [
                [lat1, lng1],
                [lat2, lng2],
              ];
              if (!lines.has(key)) {
                const line = L.polyline(coords, {
                  color: colorFromSignal(n.r),
                }).addTo(map);
                line.bindTooltip(String(n.r), {
                  permanent: true,
                  direction: "center",
                  className: "signal-label",
                });
                lines.set(key, line);
              } else {
                const line = lines.get(key);
                if (!map.hasLayer(line)) {
                  line.addTo(map);
                }
                line.setLatLngs(coords);
                line.setStyle({ color: colorFromSignal(n.r) });
                const tooltip = line.getTooltip();
                if (tooltip) {
                  const mid = line.getBounds().getCenter(); // не зависит от line._map
                  tooltip.setLatLng(mid);
                  line.setTooltipContent(String(n.r));
                }
              }
              seen.add(key);
            }
          });
        }
        for (const [key, line] of lines) {
          if (!seen.has(key)) {
            map.removeLayer(line);
            lines.delete(key);
          }
        }
        for (const [id, marker] of Array.from(markers)) {
          if (!currentIds.has(id)) {
            map.removeLayer(marker);
            markers.delete(id);
          }
        }
        if (!initialized && bounds.length) {
          map.fitBounds(bounds, { padding: [20, 20] });
          initialized = true;
        }
      }

      function fetchData() {
        fetch("/data")
          .then((res) => res.json())
          .then(updateGraph)
          .catch((err) => console.error("Failed to load data", err));
      }

      fetchData();
      setInterval(fetchData, 2000);
    </script>
  </body>
</html>
